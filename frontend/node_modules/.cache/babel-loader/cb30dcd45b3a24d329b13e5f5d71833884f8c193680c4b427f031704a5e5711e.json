{"ast":null,"code":"import { B as getDefaultExportFromCjs } from './dep-cNe07EU9.js';\nimport require$$0 from 'path';\nimport require$$0__default from 'fs';\nimport { l as lib } from './dep-IQS-Za7F.js';\nimport { fileURLToPath as __cjs_fileURLToPath } from 'node:url';\nimport { dirname as __cjs_dirname } from 'node:path';\nimport { createRequire as __cjs_createRequire } from 'node:module';\nconst __filename = __cjs_fileURLToPath(import.meta.url);\nconst __dirname = __cjs_dirname(__filename);\nconst require = __cjs_createRequire(import.meta.url);\nconst __require = require;\nfunction _mergeNamespaces(n, m) {\n  for (var i = 0; i < m.length; i++) {\n    var e = m[i];\n    if (typeof e !== 'string' && !Array.isArray(e)) {\n      for (var k in e) {\n        if (k !== 'default' && !(k in n)) {\n          n[k] = e[k];\n        }\n      }\n    }\n  }\n  return n;\n}\nvar formatImportPrelude$2 = function formatImportPrelude(layer, media, supports) {\n  const parts = [];\n  if (typeof layer !== \"undefined\") {\n    let layerParams = \"layer\";\n    if (layer) {\n      layerParams = `layer(${layer})`;\n    }\n    parts.push(layerParams);\n  }\n  if (typeof supports !== \"undefined\") {\n    parts.push(`supports(${supports})`);\n  }\n  if (typeof media !== \"undefined\") {\n    parts.push(media);\n  }\n  return parts.join(\" \");\n};\nconst formatImportPrelude$1 = formatImportPrelude$2;\n\n// Base64 encode an import with conditions\n// The order of conditions is important and is interleaved with cascade layer declarations\n// Each group of conditions and cascade layers needs to be interpreted in order\n// To achieve this we create a list of base64 encoded imports, where each import contains a stylesheet with another import.\n// Each import can define a single group of conditions and a single cascade layer.\nvar base64EncodedImport = function base64EncodedConditionalImport(prelude, conditions) {\n  conditions.reverse();\n  const first = conditions.pop();\n  let params = `${prelude} ${formatImportPrelude$1(first.layer, first.media, first.supports)}`;\n  for (const condition of conditions) {\n    params = `'data:text/css;base64,${Buffer.from(`@import ${params}`).toString(\"base64\")}' ${formatImportPrelude$1(condition.layer, condition.media, condition.supports)}`;\n  }\n  return params;\n};\nconst base64EncodedConditionalImport = base64EncodedImport;\nvar applyConditions$1 = function applyConditions(bundle, atRule) {\n  bundle.forEach(stmt => {\n    if (stmt.type === \"charset\" || stmt.type === \"warning\" || !stmt.conditions?.length) {\n      return;\n    }\n    if (stmt.type === \"import\") {\n      stmt.node.params = base64EncodedConditionalImport(stmt.fullUri, stmt.conditions);\n      return;\n    }\n    const {\n      nodes\n    } = stmt;\n    const {\n      parent\n    } = nodes[0];\n    const atRules = [];\n\n    // Convert conditions to at-rules\n    for (const condition of stmt.conditions) {\n      if (typeof condition.media !== \"undefined\") {\n        const mediaNode = atRule({\n          name: \"media\",\n          params: condition.media,\n          source: parent.source\n        });\n        atRules.push(mediaNode);\n      }\n      if (typeof condition.supports !== \"undefined\") {\n        const supportsNode = atRule({\n          name: \"supports\",\n          params: `(${condition.supports})`,\n          source: parent.source\n        });\n        atRules.push(supportsNode);\n      }\n      if (typeof condition.layer !== \"undefined\") {\n        const layerNode = atRule({\n          name: \"layer\",\n          params: condition.layer,\n          source: parent.source\n        });\n        atRules.push(layerNode);\n      }\n    }\n\n    // Add nodes to AST\n    const outerAtRule = atRules.shift();\n    const innerAtRule = atRules.reduce((previous, next) => {\n      previous.append(next);\n      return next;\n    }, outerAtRule);\n    parent.insertBefore(nodes[0], outerAtRule);\n\n    // remove nodes\n    nodes.forEach(node => {\n      node.parent = undefined;\n    });\n\n    // better output\n    nodes[0].raws.before = nodes[0].raws.before || \"\\n\";\n\n    // wrap new rules with media query and/or layer at rule\n    innerAtRule.append(nodes);\n    stmt.type = \"nodes\";\n    stmt.nodes = [outerAtRule];\n    delete stmt.node;\n  });\n};\nvar applyRaws$1 = function applyRaws(bundle) {\n  bundle.forEach((stmt, index) => {\n    if (index === 0) return;\n    if (stmt.parent) {\n      const {\n        before\n      } = stmt.parent.node.raws;\n      if (stmt.type === \"nodes\") stmt.nodes[0].raws.before = before;else stmt.node.raws.before = before;\n    } else if (stmt.type === \"nodes\") {\n      stmt.nodes[0].raws.before = stmt.nodes[0].raws.before || \"\\n\";\n    }\n  });\n};\nvar applyStyles$1 = function applyStyles(bundle, styles) {\n  styles.nodes = [];\n\n  // Strip additional statements.\n  bundle.forEach(stmt => {\n    if ([\"charset\", \"import\"].includes(stmt.type)) {\n      stmt.node.parent = undefined;\n      styles.append(stmt.node);\n    } else if (stmt.type === \"nodes\") {\n      stmt.nodes.forEach(node => {\n        node.parent = undefined;\n        styles.append(node);\n      });\n    }\n  });\n};\nvar readCache$1 = {\n  exports: {}\n};\nvar pify$2 = {\n  exports: {}\n};\nvar processFn = function (fn, P, opts) {\n  return function () {\n    var that = this;\n    var args = new Array(arguments.length);\n    for (var i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n    return new P(function (resolve, reject) {\n      args.push(function (err, result) {\n        if (err) {\n          reject(err);\n        } else if (opts.multiArgs) {\n          var results = new Array(arguments.length - 1);\n          for (var i = 1; i < arguments.length; i++) {\n            results[i - 1] = arguments[i];\n          }\n          resolve(results);\n        } else {\n          resolve(result);\n        }\n      });\n      fn.apply(that, args);\n    });\n  };\n};\nvar pify$1 = pify$2.exports = function (obj, P, opts) {\n  if (typeof P !== 'function') {\n    opts = P;\n    P = Promise;\n  }\n  opts = opts || {};\n  opts.exclude = opts.exclude || [/.+Sync$/];\n  var filter = function (key) {\n    var match = function (pattern) {\n      return typeof pattern === 'string' ? key === pattern : pattern.test(key);\n    };\n    return opts.include ? opts.include.some(match) : !opts.exclude.some(match);\n  };\n  var ret = typeof obj === 'function' ? function () {\n    if (opts.excludeMain) {\n      return obj.apply(this, arguments);\n    }\n    return processFn(obj, P, opts).apply(this, arguments);\n  } : {};\n  return Object.keys(obj).reduce(function (ret, key) {\n    var x = obj[key];\n    ret[key] = typeof x === 'function' && filter(key) ? processFn(x, P, opts) : x;\n    return ret;\n  }, ret);\n};\npify$1.all = pify$1;\nvar pifyExports = pify$2.exports;\nvar fs = require$$0__default;\nvar path$3 = require$$0;\nvar pify = pifyExports;\nvar stat = pify(fs.stat);\nvar readFile = pify(fs.readFile);\nvar resolve = path$3.resolve;\nvar cache = Object.create(null);\nfunction convert(content, encoding) {\n  if (Buffer.isEncoding(encoding)) {\n    return content.toString(encoding);\n  }\n  return content;\n}\nreadCache$1.exports = function (path, encoding) {\n  path = resolve(path);\n  return stat(path).then(function (stats) {\n    var item = cache[path];\n    if (item && item.mtime.getTime() === stats.mtime.getTime()) {\n      return convert(item.content, encoding);\n    }\n    return readFile(path).then(function (data) {\n      cache[path] = {\n        mtime: stats.mtime,\n        content: data\n      };\n      return convert(data, encoding);\n    });\n  }).catch(function (err) {\n    cache[path] = null;\n    return Promise.reject(err);\n  });\n};\nreadCache$1.exports.sync = function (path, encoding) {\n  path = resolve(path);\n  try {\n    var stats = fs.statSync(path);\n    var item = cache[path];\n    if (item && item.mtime.getTime() === stats.mtime.getTime()) {\n      return convert(item.content, encoding);\n    }\n    var data = fs.readFileSync(path);\n    cache[path] = {\n      mtime: stats.mtime,\n      content: data\n    };\n    return convert(data, encoding);\n  } catch (err) {\n    cache[path] = null;\n    throw err;\n  }\n};\nreadCache$1.exports.get = function (path, encoding) {\n  path = resolve(path);\n  if (cache[path]) {\n    return convert(cache[path].content, encoding);\n  }\n  return null;\n};\nreadCache$1.exports.clear = function () {\n  cache = Object.create(null);\n};\nvar readCacheExports = readCache$1.exports;\nconst anyDataURLRegexp = /^data:text\\/css(?:;(base64|plain))?,/i;\nconst base64DataURLRegexp = /^data:text\\/css;base64,/i;\nconst plainDataURLRegexp = /^data:text\\/css;plain,/i;\nfunction isValid(url) {\n  return anyDataURLRegexp.test(url);\n}\nfunction contents(url) {\n  if (base64DataURLRegexp.test(url)) {\n    // \"data:text/css;base64,\".length === 21\n    return Buffer.from(url.slice(21), \"base64\").toString();\n  }\n  if (plainDataURLRegexp.test(url)) {\n    // \"data:text/css;plain,\".length === 20\n    return decodeURIComponent(url.slice(20));\n  }\n\n  // \"data:text/css,\".length === 14\n  return decodeURIComponent(url.slice(14));\n}\nvar dataUrl = {\n  isValid,\n  contents\n};\nconst readCache = readCacheExports;\nconst dataURL$1 = dataUrl;\nvar loadContent$1 = function loadContent(filename) {\n  if (dataURL$1.isValid(filename)) {\n    return dataURL$1.contents(filename);\n  }\n  return readCache(filename, \"utf-8\");\n};\n\n// external tooling\nconst valueParser = lib;\n\n// extended tooling\nconst {\n  stringify\n} = valueParser;\nvar parseStatements$1 = function parseStatements(result, styles, conditions, from) {\n  const statements = [];\n  let nodes = [];\n  styles.each(node => {\n    let stmt;\n    if (node.type === \"atrule\") {\n      if (node.name === \"import\") stmt = parseImport(result, node, conditions, from);else if (node.name === \"charset\") stmt = parseCharset(result, node, conditions, from);\n    }\n    if (stmt) {\n      if (nodes.length) {\n        statements.push({\n          type: \"nodes\",\n          nodes,\n          conditions: [...conditions],\n          from\n        });\n        nodes = [];\n      }\n      statements.push(stmt);\n    } else nodes.push(node);\n  });\n  if (nodes.length) {\n    statements.push({\n      type: \"nodes\",\n      nodes,\n      conditions: [...conditions],\n      from\n    });\n  }\n  return statements;\n};\nfunction parseCharset(result, atRule, conditions, from) {\n  if (atRule.prev()) {\n    return result.warn(\"@charset must precede all other statements\", {\n      node: atRule\n    });\n  }\n  return {\n    type: \"charset\",\n    node: atRule,\n    conditions: [...conditions],\n    from\n  };\n}\nfunction parseImport(result, atRule, conditions, from) {\n  let prev = atRule.prev();\n\n  // `@import` statements may follow other `@import` statements.\n  if (prev) {\n    do {\n      if (prev.type === \"comment\" || prev.type === \"atrule\" && prev.name === \"import\") {\n        prev = prev.prev();\n        continue;\n      }\n      break;\n    } while (prev);\n  }\n\n  // All `@import` statements may be preceded by `@charset` or `@layer` statements.\n  // But the `@import` statements must be consecutive.\n  if (prev) {\n    do {\n      if (prev.type === \"comment\" || prev.type === \"atrule\" && (prev.name === \"charset\" || prev.name === \"layer\" && !prev.nodes)) {\n        prev = prev.prev();\n        continue;\n      }\n      return result.warn(\"@import must precede all other statements (besides @charset or empty @layer)\", {\n        node: atRule\n      });\n    } while (prev);\n  }\n  if (atRule.nodes) {\n    return result.warn(\"It looks like you didn't end your @import statement correctly. \" + \"Child nodes are attached to it.\", {\n      node: atRule\n    });\n  }\n  const params = valueParser(atRule.params).nodes;\n  const stmt = {\n    type: \"import\",\n    uri: \"\",\n    fullUri: \"\",\n    node: atRule,\n    conditions: [...conditions],\n    from\n  };\n  let layer;\n  let media;\n  let supports;\n  for (let i = 0; i < params.length; i++) {\n    const node = params[i];\n    if (node.type === \"space\" || node.type === \"comment\") continue;\n    if (node.type === \"string\") {\n      if (stmt.uri) {\n        return result.warn(`Multiple url's in '${atRule.toString()}'`, {\n          node: atRule\n        });\n      }\n      if (!node.value) {\n        return result.warn(`Unable to find uri in '${atRule.toString()}'`, {\n          node: atRule\n        });\n      }\n      stmt.uri = node.value;\n      stmt.fullUri = stringify(node);\n      continue;\n    }\n    if (node.type === \"function\" && /^url$/i.test(node.value)) {\n      if (stmt.uri) {\n        return result.warn(`Multiple url's in '${atRule.toString()}'`, {\n          node: atRule\n        });\n      }\n      if (!node.nodes?.[0]?.value) {\n        return result.warn(`Unable to find uri in '${atRule.toString()}'`, {\n          node: atRule\n        });\n      }\n      stmt.uri = node.nodes[0].value;\n      stmt.fullUri = stringify(node);\n      continue;\n    }\n    if (!stmt.uri) {\n      return result.warn(`Unable to find uri in '${atRule.toString()}'`, {\n        node: atRule\n      });\n    }\n    if ((node.type === \"word\" || node.type === \"function\") && /^layer$/i.test(node.value)) {\n      if (typeof layer !== \"undefined\") {\n        return result.warn(`Multiple layers in '${atRule.toString()}'`, {\n          node: atRule\n        });\n      }\n      if (typeof supports !== \"undefined\") {\n        return result.warn(`layers must be defined before support conditions in '${atRule.toString()}'`, {\n          node: atRule\n        });\n      }\n      if (node.nodes) {\n        layer = stringify(node.nodes);\n      } else {\n        layer = \"\";\n      }\n      continue;\n    }\n    if (node.type === \"function\" && /^supports$/i.test(node.value)) {\n      if (typeof supports !== \"undefined\") {\n        return result.warn(`Multiple support conditions in '${atRule.toString()}'`, {\n          node: atRule\n        });\n      }\n      supports = stringify(node.nodes);\n      continue;\n    }\n    media = stringify(params.slice(i));\n    break;\n  }\n  if (!stmt.uri) {\n    return result.warn(`Unable to find uri in '${atRule.toString()}'`, {\n      node: atRule\n    });\n  }\n  if (typeof media !== \"undefined\" || typeof layer !== \"undefined\" || typeof supports !== \"undefined\") {\n    stmt.conditions.push({\n      layer,\n      media,\n      supports\n    });\n  }\n  return stmt;\n}\n\n// builtin tooling\nconst path$2 = require$$0;\n\n// placeholder tooling\nlet sugarss;\nvar processContent$1 = function processContent(result, content, filename, options, postcss) {\n  const {\n    plugins\n  } = options;\n  const ext = path$2.extname(filename);\n  const parserList = [];\n\n  // SugarSS support:\n  if (ext === \".sss\") {\n    if (!sugarss) {\n      /* c8 ignore next 3 */\n      try {\n        sugarss = __require('sugarss');\n      } catch {} // Ignore\n    }\n    if (sugarss) return runPostcss(postcss, content, filename, plugins, [sugarss]);\n  }\n\n  // Syntax support:\n  if (result.opts.syntax?.parse) {\n    parserList.push(result.opts.syntax.parse);\n  }\n\n  // Parser support:\n  if (result.opts.parser) parserList.push(result.opts.parser);\n  // Try the default as a last resort:\n  parserList.push(null);\n  return runPostcss(postcss, content, filename, plugins, parserList);\n};\nfunction runPostcss(postcss, content, filename, plugins, parsers, index) {\n  if (!index) index = 0;\n  return postcss(plugins).process(content, {\n    from: filename,\n    parser: parsers[index]\n  }).catch(err => {\n    // If there's an error, try the next parser\n    index++;\n    // If there are no parsers left, throw it\n    if (index === parsers.length) throw err;\n    return runPostcss(postcss, content, filename, plugins, parsers, index);\n  });\n}\nconst path$1 = require$$0;\nconst dataURL = dataUrl;\nconst parseStatements = parseStatements$1;\nconst processContent = processContent$1;\nconst resolveId$1 = id => id;\nconst formatImportPrelude = formatImportPrelude$2;\nasync function parseStyles$1(result, styles, options, state, conditions, from, postcss) {\n  const statements = parseStatements(result, styles, conditions, from);\n  for (const stmt of statements) {\n    if (stmt.type !== \"import\" || !isProcessableURL(stmt.uri)) {\n      continue;\n    }\n    if (options.filter && !options.filter(stmt.uri)) {\n      // rejected by filter\n      continue;\n    }\n    await resolveImportId(result, stmt, options, state, postcss);\n  }\n  let charset;\n  const imports = [];\n  const bundle = [];\n  function handleCharset(stmt) {\n    if (!charset) charset = stmt;\n    // charsets aren't case-sensitive, so convert to lower case to compare\n    else if (stmt.node.params.toLowerCase() !== charset.node.params.toLowerCase()) {\n      throw stmt.node.error(`Incompatible @charset statements:\n  ${stmt.node.params} specified in ${stmt.node.source.input.file}\n  ${charset.node.params} specified in ${charset.node.source.input.file}`);\n    }\n  }\n\n  // squash statements and their children\n  statements.forEach(stmt => {\n    if (stmt.type === \"charset\") handleCharset(stmt);else if (stmt.type === \"import\") {\n      if (stmt.children) {\n        stmt.children.forEach((child, index) => {\n          if (child.type === \"import\") imports.push(child);else if (child.type === \"charset\") handleCharset(child);else bundle.push(child);\n          // For better output\n          if (index === 0) child.parent = stmt;\n        });\n      } else imports.push(stmt);\n    } else if (stmt.type === \"nodes\") {\n      bundle.push(stmt);\n    }\n  });\n  return charset ? [charset, ...imports.concat(bundle)] : imports.concat(bundle);\n}\nasync function resolveImportId(result, stmt, options, state, postcss) {\n  if (dataURL.isValid(stmt.uri)) {\n    // eslint-disable-next-line require-atomic-updates\n    stmt.children = await loadImportContent(result, stmt, stmt.uri, options, state, postcss);\n    return;\n  } else if (dataURL.isValid(stmt.from.slice(-1))) {\n    // Data urls can't be used as a base url to resolve imports.\n    throw stmt.node.error(`Unable to import '${stmt.uri}' from a stylesheet that is embedded in a data url`);\n  }\n  const atRule = stmt.node;\n  let sourceFile;\n  if (atRule.source?.input?.file) {\n    sourceFile = atRule.source.input.file;\n  }\n  const base = sourceFile ? path$1.dirname(atRule.source.input.file) : options.root;\n  const paths = [await options.resolve(stmt.uri, base, options, atRule)].flat();\n\n  // Ensure that each path is absolute:\n  const resolved = await Promise.all(paths.map(file => {\n    return !path$1.isAbsolute(file) ? resolveId$1(file) : file;\n  }));\n\n  // Add dependency messages:\n  resolved.forEach(file => {\n    result.messages.push({\n      type: \"dependency\",\n      plugin: \"postcss-import\",\n      file,\n      parent: sourceFile\n    });\n  });\n  const importedContent = await Promise.all(resolved.map(file => {\n    return loadImportContent(result, stmt, file, options, state, postcss);\n  }));\n\n  // Merge loaded statements\n  // eslint-disable-next-line require-atomic-updates\n  stmt.children = importedContent.flat().filter(x => !!x);\n}\nasync function loadImportContent(result, stmt, filename, options, state, postcss) {\n  const atRule = stmt.node;\n  const {\n    conditions,\n    from\n  } = stmt;\n  const stmtDuplicateCheckKey = conditions.map(condition => formatImportPrelude(condition.layer, condition.media, condition.supports)).join(\":\");\n  if (options.skipDuplicates) {\n    // skip files already imported at the same scope\n    if (state.importedFiles[filename]?.[stmtDuplicateCheckKey]) {\n      return;\n    }\n\n    // save imported files to skip them next time\n    if (!state.importedFiles[filename]) {\n      state.importedFiles[filename] = {};\n    }\n    state.importedFiles[filename][stmtDuplicateCheckKey] = true;\n  }\n  if (from.includes(filename)) {\n    return;\n  }\n  const content = await options.load(filename, options);\n  if (content.trim() === \"\" && options.warnOnEmpty) {\n    result.warn(`${filename} is empty`, {\n      node: atRule\n    });\n    return;\n  }\n\n  // skip previous imported files not containing @import rules\n  if (options.skipDuplicates && state.hashFiles[content]?.[stmtDuplicateCheckKey]) {\n    return;\n  }\n  const importedResult = await processContent(result, content, filename, options, postcss);\n  const styles = importedResult.root;\n  result.messages = result.messages.concat(importedResult.messages);\n  if (options.skipDuplicates) {\n    const hasImport = styles.some(child => {\n      return child.type === \"atrule\" && child.name === \"import\";\n    });\n    if (!hasImport) {\n      // save hash files to skip them next time\n      if (!state.hashFiles[content]) {\n        state.hashFiles[content] = {};\n      }\n      state.hashFiles[content][stmtDuplicateCheckKey] = true;\n    }\n  }\n\n  // recursion: import @import from imported file\n  return parseStyles$1(result, styles, options, state, conditions, [...from, filename], postcss);\n}\nfunction isProcessableURL(uri) {\n  // skip protocol base uri (protocol://url) or protocol-relative\n  if (/^(?:[a-z]+:)?\\/\\//i.test(uri)) {\n    return false;\n  }\n\n  // check for fragment or query\n  try {\n    // needs a base to parse properly\n    const url = new URL(uri, \"https://example.com\");\n    if (url.search) {\n      return false;\n    }\n  } catch {} // Ignore\n\n  return true;\n}\nvar parseStyles_1 = parseStyles$1;\n\n// builtin tooling\nconst path = require$$0;\n\n// internal tooling\nconst applyConditions = applyConditions$1;\nconst applyRaws = applyRaws$1;\nconst applyStyles = applyStyles$1;\nconst loadContent = loadContent$1;\nconst parseStyles = parseStyles_1;\nconst resolveId = id => id;\nfunction AtImport(options) {\n  options = {\n    root: process.cwd(),\n    path: [],\n    skipDuplicates: true,\n    resolve: resolveId,\n    load: loadContent,\n    plugins: [],\n    addModulesDirectories: [],\n    warnOnEmpty: true,\n    ...options\n  };\n  options.root = path.resolve(options.root);\n\n  // convert string to an array of a single element\n  if (typeof options.path === \"string\") options.path = [options.path];\n  if (!Array.isArray(options.path)) options.path = [];\n  options.path = options.path.map(p => path.resolve(options.root, p));\n  return {\n    postcssPlugin: \"postcss-import\",\n    async Once(styles, {\n      result,\n      atRule,\n      postcss\n    }) {\n      const state = {\n        importedFiles: {},\n        hashFiles: {}\n      };\n      if (styles.source?.input?.file) {\n        state.importedFiles[styles.source.input.file] = {};\n      }\n      if (options.plugins && !Array.isArray(options.plugins)) {\n        throw new Error(\"plugins option must be an array\");\n      }\n      const bundle = await parseStyles(result, styles, options, state, [], [], postcss);\n      applyRaws(bundle);\n      applyConditions(bundle, atRule);\n      applyStyles(bundle, styles);\n    }\n  };\n}\nAtImport.postcss = true;\nvar postcssImport = AtImport;\nvar index = /*@__PURE__*/getDefaultExportFromCjs(postcssImport);\nvar index$1 = /*#__PURE__*/_mergeNamespaces({\n  __proto__: null,\n  default: index\n}, [postcssImport]);\nexport { index$1 as i };","map":{"version":3,"names":["B","getDefaultExportFromCjs","require$$0","require$$0__default","l","lib","fileURLToPath","__cjs_fileURLToPath","dirname","__cjs_dirname","createRequire","__cjs_createRequire","__filename","import","meta","url","__dirname","require","__require","_mergeNamespaces","n","m","i","length","e","Array","isArray","k","formatImportPrelude$2","formatImportPrelude","layer","media","supports","parts","layerParams","push","join","formatImportPrelude$1","base64EncodedImport","base64EncodedConditionalImport","prelude","conditions","reverse","first","pop","params","condition","Buffer","from","toString","applyConditions$1","applyConditions","bundle","atRule","forEach","stmt","type","node","fullUri","nodes","parent","atRules","mediaNode","name","source","supportsNode","layerNode","outerAtRule","shift","innerAtRule","reduce","previous","next","append","insertBefore","undefined","raws","before","applyRaws$1","applyRaws","index","applyStyles$1","applyStyles","styles","includes","readCache$1","exports","pify$2","processFn","fn","P","opts","that","args","arguments","resolve","reject","err","result","multiArgs","results","apply","pify$1","obj","Promise","exclude","filter","key","match","pattern","test","include","some","ret","excludeMain","Object","keys","x","all","pifyExports","fs","path$3","pify","stat","readFile","cache","create","convert","content","encoding","isEncoding","path","then","stats","item","mtime","getTime","data","catch","sync","statSync","readFileSync","get","clear","readCacheExports","anyDataURLRegexp","base64DataURLRegexp","plainDataURLRegexp","isValid","contents","slice","decodeURIComponent","dataUrl","readCache","dataURL$1","loadContent$1","loadContent","filename","valueParser","stringify","parseStatements$1","parseStatements","statements","each","parseImport","parseCharset","prev","warn","uri","value","path$2","sugarss","processContent$1","processContent","options","postcss","plugins","ext","extname","parserList","runPostcss","syntax","parse","parser","parsers","process","path$1","dataURL","resolveId$1","id","parseStyles$1","state","isProcessableURL","resolveImportId","charset","imports","handleCharset","toLowerCase","error","input","file","children","child","concat","loadImportContent","sourceFile","base","root","paths","flat","resolved","map","isAbsolute","messages","plugin","importedContent","stmtDuplicateCheckKey","skipDuplicates","importedFiles","load","trim","warnOnEmpty","hashFiles","importedResult","hasImport","URL","search","parseStyles_1","parseStyles","resolveId","AtImport","cwd","addModulesDirectories","p","postcssPlugin","Once","Error","postcssImport","index$1","__proto__","default"],"sources":["/Users/kaushiknag/node_modules/vite/dist/node/chunks/dep-DyOjWWe9.js"],"sourcesContent":["import { B as getDefaultExportFromCjs } from './dep-cNe07EU9.js';\nimport require$$0 from 'path';\nimport require$$0__default from 'fs';\nimport { l as lib } from './dep-IQS-Za7F.js';\n\nimport { fileURLToPath as __cjs_fileURLToPath } from 'node:url';\nimport { dirname as __cjs_dirname } from 'node:path';\nimport { createRequire as __cjs_createRequire } from 'node:module';\n\nconst __filename = __cjs_fileURLToPath(import.meta.url);\nconst __dirname = __cjs_dirname(__filename);\nconst require = __cjs_createRequire(import.meta.url);\nconst __require = require;\nfunction _mergeNamespaces(n, m) {\n  for (var i = 0; i < m.length; i++) {\n    var e = m[i];\n    if (typeof e !== 'string' && !Array.isArray(e)) { for (var k in e) {\n      if (k !== 'default' && !(k in n)) {\n        n[k] = e[k];\n      }\n    } }\n  }\n  return n;\n}\n\nvar formatImportPrelude$2 = function formatImportPrelude(layer, media, supports) {\n  const parts = [];\n\n  if (typeof layer !== \"undefined\") {\n    let layerParams = \"layer\";\n    if (layer) {\n      layerParams = `layer(${layer})`;\n    }\n\n    parts.push(layerParams);\n  }\n\n  if (typeof supports !== \"undefined\") {\n    parts.push(`supports(${supports})`);\n  }\n\n  if (typeof media !== \"undefined\") {\n    parts.push(media);\n  }\n\n  return parts.join(\" \")\n};\n\nconst formatImportPrelude$1 = formatImportPrelude$2;\n\n// Base64 encode an import with conditions\n// The order of conditions is important and is interleaved with cascade layer declarations\n// Each group of conditions and cascade layers needs to be interpreted in order\n// To achieve this we create a list of base64 encoded imports, where each import contains a stylesheet with another import.\n// Each import can define a single group of conditions and a single cascade layer.\nvar base64EncodedImport = function base64EncodedConditionalImport(prelude, conditions) {\n  conditions.reverse();\n  const first = conditions.pop();\n  let params = `${prelude} ${formatImportPrelude$1(\n    first.layer,\n    first.media,\n    first.supports,\n  )}`;\n\n  for (const condition of conditions) {\n    params = `'data:text/css;base64,${Buffer.from(`@import ${params}`).toString(\n      \"base64\",\n    )}' ${formatImportPrelude$1(\n      condition.layer,\n      condition.media,\n      condition.supports,\n    )}`;\n  }\n\n  return params\n};\n\nconst base64EncodedConditionalImport = base64EncodedImport;\n\nvar applyConditions$1 = function applyConditions(bundle, atRule) {\n  bundle.forEach(stmt => {\n    if (\n      stmt.type === \"charset\" ||\n      stmt.type === \"warning\" ||\n      !stmt.conditions?.length\n    ) {\n      return\n    }\n\n    if (stmt.type === \"import\") {\n      stmt.node.params = base64EncodedConditionalImport(\n        stmt.fullUri,\n        stmt.conditions,\n      );\n      return\n    }\n\n    const { nodes } = stmt;\n    const { parent } = nodes[0];\n\n    const atRules = [];\n\n    // Convert conditions to at-rules\n    for (const condition of stmt.conditions) {\n      if (typeof condition.media !== \"undefined\") {\n        const mediaNode = atRule({\n          name: \"media\",\n          params: condition.media,\n          source: parent.source,\n        });\n\n        atRules.push(mediaNode);\n      }\n\n      if (typeof condition.supports !== \"undefined\") {\n        const supportsNode = atRule({\n          name: \"supports\",\n          params: `(${condition.supports})`,\n          source: parent.source,\n        });\n\n        atRules.push(supportsNode);\n      }\n\n      if (typeof condition.layer !== \"undefined\") {\n        const layerNode = atRule({\n          name: \"layer\",\n          params: condition.layer,\n          source: parent.source,\n        });\n\n        atRules.push(layerNode);\n      }\n    }\n\n    // Add nodes to AST\n    const outerAtRule = atRules.shift();\n    const innerAtRule = atRules.reduce((previous, next) => {\n      previous.append(next);\n      return next\n    }, outerAtRule);\n\n    parent.insertBefore(nodes[0], outerAtRule);\n\n    // remove nodes\n    nodes.forEach(node => {\n      node.parent = undefined;\n    });\n\n    // better output\n    nodes[0].raws.before = nodes[0].raws.before || \"\\n\";\n\n    // wrap new rules with media query and/or layer at rule\n    innerAtRule.append(nodes);\n\n    stmt.type = \"nodes\";\n    stmt.nodes = [outerAtRule];\n    delete stmt.node;\n  });\n};\n\nvar applyRaws$1 = function applyRaws(bundle) {\n  bundle.forEach((stmt, index) => {\n    if (index === 0) return\n\n    if (stmt.parent) {\n      const { before } = stmt.parent.node.raws;\n      if (stmt.type === \"nodes\") stmt.nodes[0].raws.before = before;\n      else stmt.node.raws.before = before;\n    } else if (stmt.type === \"nodes\") {\n      stmt.nodes[0].raws.before = stmt.nodes[0].raws.before || \"\\n\";\n    }\n  });\n};\n\nvar applyStyles$1 = function applyStyles(bundle, styles) {\n  styles.nodes = [];\n\n  // Strip additional statements.\n  bundle.forEach(stmt => {\n    if ([\"charset\", \"import\"].includes(stmt.type)) {\n      stmt.node.parent = undefined;\n      styles.append(stmt.node);\n    } else if (stmt.type === \"nodes\") {\n      stmt.nodes.forEach(node => {\n        node.parent = undefined;\n        styles.append(node);\n      });\n    }\n  });\n};\n\nvar readCache$1 = {exports: {}};\n\nvar pify$2 = {exports: {}};\n\nvar processFn = function (fn, P, opts) {\n\treturn function () {\n\t\tvar that = this;\n\t\tvar args = new Array(arguments.length);\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\n\t\treturn new P(function (resolve, reject) {\n\t\t\targs.push(function (err, result) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else if (opts.multiArgs) {\n\t\t\t\t\tvar results = new Array(arguments.length - 1);\n\n\t\t\t\t\tfor (var i = 1; i < arguments.length; i++) {\n\t\t\t\t\t\tresults[i - 1] = arguments[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(results);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfn.apply(that, args);\n\t\t});\n\t};\n};\n\nvar pify$1 = pify$2.exports = function (obj, P, opts) {\n\tif (typeof P !== 'function') {\n\t\topts = P;\n\t\tP = Promise;\n\t}\n\n\topts = opts || {};\n\topts.exclude = opts.exclude || [/.+Sync$/];\n\n\tvar filter = function (key) {\n\t\tvar match = function (pattern) {\n\t\t\treturn typeof pattern === 'string' ? key === pattern : pattern.test(key);\n\t\t};\n\n\t\treturn opts.include ? opts.include.some(match) : !opts.exclude.some(match);\n\t};\n\n\tvar ret = typeof obj === 'function' ? function () {\n\t\tif (opts.excludeMain) {\n\t\t\treturn obj.apply(this, arguments);\n\t\t}\n\n\t\treturn processFn(obj, P, opts).apply(this, arguments);\n\t} : {};\n\n\treturn Object.keys(obj).reduce(function (ret, key) {\n\t\tvar x = obj[key];\n\n\t\tret[key] = typeof x === 'function' && filter(key) ? processFn(x, P, opts) : x;\n\n\t\treturn ret;\n\t}, ret);\n};\n\npify$1.all = pify$1;\n\nvar pifyExports = pify$2.exports;\n\nvar fs = require$$0__default;\r\nvar path$3 = require$$0;\r\nvar pify = pifyExports;\r\n\r\nvar stat = pify(fs.stat);\r\nvar readFile = pify(fs.readFile);\r\nvar resolve = path$3.resolve;\r\n\r\nvar cache = Object.create(null);\r\n\r\nfunction convert(content, encoding) {\r\n\tif (Buffer.isEncoding(encoding)) {\r\n\t\treturn content.toString(encoding);\r\n\t}\r\n\treturn content;\r\n}\r\n\r\nreadCache$1.exports = function (path, encoding) {\r\n\tpath = resolve(path);\r\n\r\n\treturn stat(path).then(function (stats) {\r\n\t\tvar item = cache[path];\r\n\r\n\t\tif (item && item.mtime.getTime() === stats.mtime.getTime()) {\r\n\t\t\treturn convert(item.content, encoding);\r\n\t\t}\r\n\r\n\t\treturn readFile(path).then(function (data) {\r\n\t\t\tcache[path] = {\r\n\t\t\t\tmtime: stats.mtime,\r\n\t\t\t\tcontent: data\r\n\t\t\t};\r\n\r\n\t\t\treturn convert(data, encoding);\r\n\t\t});\r\n\t}).catch(function (err) {\r\n\t\tcache[path] = null;\r\n\t\treturn Promise.reject(err);\r\n\t});\r\n};\r\n\r\nreadCache$1.exports.sync = function (path, encoding) {\r\n\tpath = resolve(path);\r\n\r\n\ttry {\r\n\t\tvar stats = fs.statSync(path);\r\n\t\tvar item = cache[path];\r\n\r\n\t\tif (item && item.mtime.getTime() === stats.mtime.getTime()) {\r\n\t\t\treturn convert(item.content, encoding);\r\n\t\t}\r\n\r\n\t\tvar data = fs.readFileSync(path);\r\n\r\n\t\tcache[path] = {\r\n\t\t\tmtime: stats.mtime,\r\n\t\t\tcontent: data\r\n\t\t};\r\n\r\n\t\treturn convert(data, encoding);\r\n\t} catch (err) {\r\n\t\tcache[path] = null;\r\n\t\tthrow err;\r\n\t}\r\n\r\n};\r\n\r\nreadCache$1.exports.get = function (path, encoding) {\r\n\tpath = resolve(path);\r\n\tif (cache[path]) {\r\n\t\treturn convert(cache[path].content, encoding);\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nreadCache$1.exports.clear = function () {\r\n\tcache = Object.create(null);\r\n};\n\nvar readCacheExports = readCache$1.exports;\n\nconst anyDataURLRegexp = /^data:text\\/css(?:;(base64|plain))?,/i;\nconst base64DataURLRegexp = /^data:text\\/css;base64,/i;\nconst plainDataURLRegexp = /^data:text\\/css;plain,/i;\n\nfunction isValid(url) {\n  return anyDataURLRegexp.test(url)\n}\n\nfunction contents(url) {\n  if (base64DataURLRegexp.test(url)) {\n    // \"data:text/css;base64,\".length === 21\n    return Buffer.from(url.slice(21), \"base64\").toString()\n  }\n\n  if (plainDataURLRegexp.test(url)) {\n    // \"data:text/css;plain,\".length === 20\n    return decodeURIComponent(url.slice(20))\n  }\n\n  // \"data:text/css,\".length === 14\n  return decodeURIComponent(url.slice(14))\n}\n\nvar dataUrl = {\n  isValid,\n  contents,\n};\n\nconst readCache = readCacheExports;\nconst dataURL$1 = dataUrl;\n\nvar loadContent$1 = function loadContent(filename) {\n  if (dataURL$1.isValid(filename)) {\n    return dataURL$1.contents(filename)\n  }\n\n  return readCache(filename, \"utf-8\")\n};\n\n// external tooling\nconst valueParser = lib;\n\n// extended tooling\nconst { stringify } = valueParser;\n\nvar parseStatements$1 = function parseStatements(result, styles, conditions, from) {\n  const statements = [];\n  let nodes = [];\n\n  styles.each(node => {\n    let stmt;\n    if (node.type === \"atrule\") {\n      if (node.name === \"import\")\n        stmt = parseImport(result, node, conditions, from);\n      else if (node.name === \"charset\")\n        stmt = parseCharset(result, node, conditions, from);\n    }\n\n    if (stmt) {\n      if (nodes.length) {\n        statements.push({\n          type: \"nodes\",\n          nodes,\n          conditions: [...conditions],\n          from,\n        });\n        nodes = [];\n      }\n      statements.push(stmt);\n    } else nodes.push(node);\n  });\n\n  if (nodes.length) {\n    statements.push({\n      type: \"nodes\",\n      nodes,\n      conditions: [...conditions],\n      from,\n    });\n  }\n\n  return statements\n};\n\nfunction parseCharset(result, atRule, conditions, from) {\n  if (atRule.prev()) {\n    return result.warn(\"@charset must precede all other statements\", {\n      node: atRule,\n    })\n  }\n  return {\n    type: \"charset\",\n    node: atRule,\n    conditions: [...conditions],\n    from,\n  }\n}\n\nfunction parseImport(result, atRule, conditions, from) {\n  let prev = atRule.prev();\n\n  // `@import` statements may follow other `@import` statements.\n  if (prev) {\n    do {\n      if (\n        prev.type === \"comment\" ||\n        (prev.type === \"atrule\" && prev.name === \"import\")\n      ) {\n        prev = prev.prev();\n        continue\n      }\n\n      break\n    } while (prev)\n  }\n\n  // All `@import` statements may be preceded by `@charset` or `@layer` statements.\n  // But the `@import` statements must be consecutive.\n  if (prev) {\n    do {\n      if (\n        prev.type === \"comment\" ||\n        (prev.type === \"atrule\" &&\n          (prev.name === \"charset\" || (prev.name === \"layer\" && !prev.nodes)))\n      ) {\n        prev = prev.prev();\n        continue\n      }\n\n      return result.warn(\n        \"@import must precede all other statements (besides @charset or empty @layer)\",\n        { node: atRule },\n      )\n    } while (prev)\n  }\n\n  if (atRule.nodes) {\n    return result.warn(\n      \"It looks like you didn't end your @import statement correctly. \" +\n        \"Child nodes are attached to it.\",\n      { node: atRule },\n    )\n  }\n\n  const params = valueParser(atRule.params).nodes;\n  const stmt = {\n    type: \"import\",\n    uri: \"\",\n    fullUri: \"\",\n    node: atRule,\n    conditions: [...conditions],\n    from,\n  };\n\n  let layer;\n  let media;\n  let supports;\n\n  for (let i = 0; i < params.length; i++) {\n    const node = params[i];\n\n    if (node.type === \"space\" || node.type === \"comment\") continue\n\n    if (node.type === \"string\") {\n      if (stmt.uri) {\n        return result.warn(`Multiple url's in '${atRule.toString()}'`, {\n          node: atRule,\n        })\n      }\n\n      if (!node.value) {\n        return result.warn(`Unable to find uri in '${atRule.toString()}'`, {\n          node: atRule,\n        })\n      }\n\n      stmt.uri = node.value;\n      stmt.fullUri = stringify(node);\n      continue\n    }\n\n    if (node.type === \"function\" && /^url$/i.test(node.value)) {\n      if (stmt.uri) {\n        return result.warn(`Multiple url's in '${atRule.toString()}'`, {\n          node: atRule,\n        })\n      }\n\n      if (!node.nodes?.[0]?.value) {\n        return result.warn(`Unable to find uri in '${atRule.toString()}'`, {\n          node: atRule,\n        })\n      }\n\n      stmt.uri = node.nodes[0].value;\n      stmt.fullUri = stringify(node);\n      continue\n    }\n\n    if (!stmt.uri) {\n      return result.warn(`Unable to find uri in '${atRule.toString()}'`, {\n        node: atRule,\n      })\n    }\n\n    if (\n      (node.type === \"word\" || node.type === \"function\") &&\n      /^layer$/i.test(node.value)\n    ) {\n      if (typeof layer !== \"undefined\") {\n        return result.warn(`Multiple layers in '${atRule.toString()}'`, {\n          node: atRule,\n        })\n      }\n\n      if (typeof supports !== \"undefined\") {\n        return result.warn(\n          `layers must be defined before support conditions in '${atRule.toString()}'`,\n          {\n            node: atRule,\n          },\n        )\n      }\n\n      if (node.nodes) {\n        layer = stringify(node.nodes);\n      } else {\n        layer = \"\";\n      }\n\n      continue\n    }\n\n    if (node.type === \"function\" && /^supports$/i.test(node.value)) {\n      if (typeof supports !== \"undefined\") {\n        return result.warn(\n          `Multiple support conditions in '${atRule.toString()}'`,\n          {\n            node: atRule,\n          },\n        )\n      }\n\n      supports = stringify(node.nodes);\n\n      continue\n    }\n\n    media = stringify(params.slice(i));\n    break\n  }\n\n  if (!stmt.uri) {\n    return result.warn(`Unable to find uri in '${atRule.toString()}'`, {\n      node: atRule,\n    })\n  }\n\n  if (\n    typeof media !== \"undefined\" ||\n    typeof layer !== \"undefined\" ||\n    typeof supports !== \"undefined\"\n  ) {\n    stmt.conditions.push({\n      layer,\n      media,\n      supports,\n    });\n  }\n\n  return stmt\n}\n\n// builtin tooling\nconst path$2 = require$$0;\n\n// placeholder tooling\nlet sugarss;\n\nvar processContent$1 = function processContent(\n  result,\n  content,\n  filename,\n  options,\n  postcss,\n) {\n  const { plugins } = options;\n  const ext = path$2.extname(filename);\n\n  const parserList = [];\n\n  // SugarSS support:\n  if (ext === \".sss\") {\n    if (!sugarss) {\n      /* c8 ignore next 3 */\n      try {\n        sugarss = __require('sugarss');\n      } catch {} // Ignore\n    }\n    if (sugarss)\n      return runPostcss(postcss, content, filename, plugins, [sugarss])\n  }\n\n  // Syntax support:\n  if (result.opts.syntax?.parse) {\n    parserList.push(result.opts.syntax.parse);\n  }\n\n  // Parser support:\n  if (result.opts.parser) parserList.push(result.opts.parser);\n  // Try the default as a last resort:\n  parserList.push(null);\n\n  return runPostcss(postcss, content, filename, plugins, parserList)\n};\n\nfunction runPostcss(postcss, content, filename, plugins, parsers, index) {\n  if (!index) index = 0;\n  return postcss(plugins)\n    .process(content, {\n      from: filename,\n      parser: parsers[index],\n    })\n    .catch(err => {\n      // If there's an error, try the next parser\n      index++;\n      // If there are no parsers left, throw it\n      if (index === parsers.length) throw err\n      return runPostcss(postcss, content, filename, plugins, parsers, index)\n    })\n}\n\nconst path$1 = require$$0;\n\nconst dataURL = dataUrl;\nconst parseStatements = parseStatements$1;\nconst processContent = processContent$1;\nconst resolveId$1 = (id) => id;\nconst formatImportPrelude = formatImportPrelude$2;\n\nasync function parseStyles$1(\n  result,\n  styles,\n  options,\n  state,\n  conditions,\n  from,\n  postcss,\n) {\n  const statements = parseStatements(result, styles, conditions, from);\n\n  for (const stmt of statements) {\n    if (stmt.type !== \"import\" || !isProcessableURL(stmt.uri)) {\n      continue\n    }\n\n    if (options.filter && !options.filter(stmt.uri)) {\n      // rejected by filter\n      continue\n    }\n\n    await resolveImportId(result, stmt, options, state, postcss);\n  }\n\n  let charset;\n  const imports = [];\n  const bundle = [];\n\n  function handleCharset(stmt) {\n    if (!charset) charset = stmt;\n    // charsets aren't case-sensitive, so convert to lower case to compare\n    else if (\n      stmt.node.params.toLowerCase() !== charset.node.params.toLowerCase()\n    ) {\n      throw stmt.node.error(\n        `Incompatible @charset statements:\n  ${stmt.node.params} specified in ${stmt.node.source.input.file}\n  ${charset.node.params} specified in ${charset.node.source.input.file}`,\n      )\n    }\n  }\n\n  // squash statements and their children\n  statements.forEach(stmt => {\n    if (stmt.type === \"charset\") handleCharset(stmt);\n    else if (stmt.type === \"import\") {\n      if (stmt.children) {\n        stmt.children.forEach((child, index) => {\n          if (child.type === \"import\") imports.push(child);\n          else if (child.type === \"charset\") handleCharset(child);\n          else bundle.push(child);\n          // For better output\n          if (index === 0) child.parent = stmt;\n        });\n      } else imports.push(stmt);\n    } else if (stmt.type === \"nodes\") {\n      bundle.push(stmt);\n    }\n  });\n\n  return charset ? [charset, ...imports.concat(bundle)] : imports.concat(bundle)\n}\n\nasync function resolveImportId(result, stmt, options, state, postcss) {\n  if (dataURL.isValid(stmt.uri)) {\n    // eslint-disable-next-line require-atomic-updates\n    stmt.children = await loadImportContent(\n      result,\n      stmt,\n      stmt.uri,\n      options,\n      state,\n      postcss,\n    );\n\n    return\n  } else if (dataURL.isValid(stmt.from.slice(-1))) {\n    // Data urls can't be used as a base url to resolve imports.\n    throw stmt.node.error(\n      `Unable to import '${stmt.uri}' from a stylesheet that is embedded in a data url`,\n    )\n  }\n\n  const atRule = stmt.node;\n  let sourceFile;\n  if (atRule.source?.input?.file) {\n    sourceFile = atRule.source.input.file;\n  }\n  const base = sourceFile\n    ? path$1.dirname(atRule.source.input.file)\n    : options.root;\n\n  const paths = [await options.resolve(stmt.uri, base, options, atRule)].flat();\n\n  // Ensure that each path is absolute:\n  const resolved = await Promise.all(\n    paths.map(file => {\n      return !path$1.isAbsolute(file)\n        ? resolveId$1(file)\n        : file\n    }),\n  );\n\n  // Add dependency messages:\n  resolved.forEach(file => {\n    result.messages.push({\n      type: \"dependency\",\n      plugin: \"postcss-import\",\n      file,\n      parent: sourceFile,\n    });\n  });\n\n  const importedContent = await Promise.all(\n    resolved.map(file => {\n      return loadImportContent(result, stmt, file, options, state, postcss)\n    }),\n  );\n\n  // Merge loaded statements\n  // eslint-disable-next-line require-atomic-updates\n  stmt.children = importedContent.flat().filter(x => !!x);\n}\n\nasync function loadImportContent(\n  result,\n  stmt,\n  filename,\n  options,\n  state,\n  postcss,\n) {\n  const atRule = stmt.node;\n  const { conditions, from } = stmt;\n  const stmtDuplicateCheckKey = conditions\n    .map(condition =>\n      formatImportPrelude(condition.layer, condition.media, condition.supports),\n    )\n    .join(\":\");\n\n  if (options.skipDuplicates) {\n    // skip files already imported at the same scope\n    if (state.importedFiles[filename]?.[stmtDuplicateCheckKey]) {\n      return\n    }\n\n    // save imported files to skip them next time\n    if (!state.importedFiles[filename]) {\n      state.importedFiles[filename] = {};\n    }\n    state.importedFiles[filename][stmtDuplicateCheckKey] = true;\n  }\n\n  if (from.includes(filename)) {\n    return\n  }\n\n  const content = await options.load(filename, options);\n\n  if (content.trim() === \"\" && options.warnOnEmpty) {\n    result.warn(`${filename} is empty`, { node: atRule });\n    return\n  }\n\n  // skip previous imported files not containing @import rules\n  if (\n    options.skipDuplicates &&\n    state.hashFiles[content]?.[stmtDuplicateCheckKey]\n  ) {\n    return\n  }\n\n  const importedResult = await processContent(\n    result,\n    content,\n    filename,\n    options,\n    postcss,\n  );\n\n  const styles = importedResult.root;\n  result.messages = result.messages.concat(importedResult.messages);\n\n  if (options.skipDuplicates) {\n    const hasImport = styles.some(child => {\n      return child.type === \"atrule\" && child.name === \"import\"\n    });\n    if (!hasImport) {\n      // save hash files to skip them next time\n      if (!state.hashFiles[content]) {\n        state.hashFiles[content] = {};\n      }\n\n      state.hashFiles[content][stmtDuplicateCheckKey] = true;\n    }\n  }\n\n  // recursion: import @import from imported file\n  return parseStyles$1(\n    result,\n    styles,\n    options,\n    state,\n    conditions,\n    [...from, filename],\n    postcss,\n  )\n}\n\nfunction isProcessableURL(uri) {\n  // skip protocol base uri (protocol://url) or protocol-relative\n  if (/^(?:[a-z]+:)?\\/\\//i.test(uri)) {\n    return false\n  }\n\n  // check for fragment or query\n  try {\n    // needs a base to parse properly\n    const url = new URL(uri, \"https://example.com\");\n    if (url.search) {\n      return false\n    }\n  } catch {} // Ignore\n\n  return true\n}\n\nvar parseStyles_1 = parseStyles$1;\n\n// builtin tooling\nconst path = require$$0;\n\n// internal tooling\nconst applyConditions = applyConditions$1;\nconst applyRaws = applyRaws$1;\nconst applyStyles = applyStyles$1;\nconst loadContent = loadContent$1;\nconst parseStyles = parseStyles_1;\nconst resolveId = (id) => id;\n\nfunction AtImport(options) {\n  options = {\n    root: process.cwd(),\n    path: [],\n    skipDuplicates: true,\n    resolve: resolveId,\n    load: loadContent,\n    plugins: [],\n    addModulesDirectories: [],\n    warnOnEmpty: true,\n    ...options,\n  };\n\n  options.root = path.resolve(options.root);\n\n  // convert string to an array of a single element\n  if (typeof options.path === \"string\") options.path = [options.path];\n\n  if (!Array.isArray(options.path)) options.path = [];\n\n  options.path = options.path.map(p => path.resolve(options.root, p));\n\n  return {\n    postcssPlugin: \"postcss-import\",\n    async Once(styles, { result, atRule, postcss }) {\n      const state = {\n        importedFiles: {},\n        hashFiles: {},\n      };\n\n      if (styles.source?.input?.file) {\n        state.importedFiles[styles.source.input.file] = {};\n      }\n\n      if (options.plugins && !Array.isArray(options.plugins)) {\n        throw new Error(\"plugins option must be an array\")\n      }\n\n      const bundle = await parseStyles(\n        result,\n        styles,\n        options,\n        state,\n        [],\n        [],\n        postcss,\n      );\n\n      applyRaws(bundle);\n      applyConditions(bundle, atRule);\n      applyStyles(bundle, styles);\n    },\n  }\n}\n\nAtImport.postcss = true;\n\nvar postcssImport = AtImport;\n\nvar index = /*@__PURE__*/getDefaultExportFromCjs(postcssImport);\n\nvar index$1 = /*#__PURE__*/_mergeNamespaces({\n  __proto__: null,\n  default: index\n}, [postcssImport]);\n\nexport { index$1 as i };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}